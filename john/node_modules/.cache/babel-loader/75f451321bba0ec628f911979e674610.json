{"ast":null,"code":"/*\n@params: grid: boolean[][], int row, int col\n@result: number of alive adjacent cells\n*/\nexport const getCellsAlive = (grid, row, col) => {\n  let result = 0;\n\n  for (let i = row > 0 ? -1 : 0; i < (row < grid.length - 1 ? 2 : 1); i++) {\n    for (let j = col > 0 ? -1 : 0; j < (col < grid[0].length - 1 ? 2 : 1); j++) {\n      if (i === 0 && j === 0) {\n        continue;\n      }\n\n      const x = row + i;\n      const y = col + j;\n\n      if (grid[x][y] === true) {\n        result += 1;\n      }\n    }\n  }\n\n  return result;\n};\nexport const getNextState = grid => {\n  const nextGrid = grid.map(arr => arr.slice());\n  let nextCellsAlive = 0;\n\n  for (let row = 0; row < nextGrid.length; row++) {\n    for (let col = 0; col < nextGrid[0].length; col++) {\n      let aliveNeighbors = getCellsAlive(grid, row, col);\n\n      if (aliveNeighbors === 3) {\n        // any cell with 3 live cells lives\n        nextGrid[row][col] = true;\n        nextCellsAlive += 1;\n      } else if (aliveNeighbors === 2 && nextGrid[row][col] === true) {\n        // live cells with 2 live cells live\n        nextGrid[row][col] = true;\n        nextCellsAlive += 1;\n      } else {\n        // all else die or stay dead\n        nextGrid[row][col] = false;\n      }\n    }\n  }\n\n  return {\n    nextGrid,\n    nextCellsAlive\n  };\n};","map":{"version":3,"sources":["/home/jschneck/programming_projects/JavaScriptProjects/Conways-Game-of-Life/john/src/utils.ts"],"names":["getCellsAlive","grid","row","col","result","i","length","j","x","y","getNextState","nextGrid","map","arr","slice","nextCellsAlive","aliveNeighbors"],"mappings":"AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,aAAa,GAAG,CAACC,IAAD,EAAoBC,GAApB,EAAiCC,GAAjC,KAAyD;AACrF,MAAIC,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIC,CAAC,GAAIH,GAAG,GAAG,CAAN,GAAU,CAAC,CAAX,GAAe,CAA7B,EAAiCG,CAAC,IAAIH,GAAG,GAAGD,IAAI,CAACK,MAAL,GAAc,CAApB,GAAwB,CAAxB,GAA4B,CAAhC,CAAlC,EAAsED,CAAC,EAAvE,EAA2E;AAC1E,SAAK,IAAIE,CAAC,GAAIJ,GAAG,GAAG,CAAN,GAAU,CAAC,CAAX,GAAe,CAA7B,EAAiCI,CAAC,IAAIJ,GAAG,GAAGF,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,GAAiB,CAAvB,GAA2B,CAA3B,GAA+B,CAAnC,CAAlC,EAAyEC,CAAC,EAA1E,EAA8E;AAC7E,UAAIF,CAAC,KAAK,CAAN,IAAWE,CAAC,KAAK,CAArB,EAAwB;AACxB;AACC;;AACD,YAAMC,CAAC,GAAGN,GAAG,GAAGG,CAAhB;AACA,YAAMI,CAAC,GAAGN,GAAG,GAAGI,CAAhB;;AACA,UAAIN,IAAI,CAACO,CAAD,CAAJ,CAAQC,CAAR,MAAe,IAAnB,EAAyB;AACzBL,QAAAA,MAAM,IAAI,CAAV;AACC;AACD;AACD;;AACD,SAAOA,MAAP;AACA,CAfM;AAsBP,OAAO,MAAMM,YAAY,GAAIT,IAAD,IAAsC;AACjE,QAAMU,QAAQ,GAAGV,IAAI,CAACW,GAAL,CAAUC,GAAG,IAAIA,GAAG,CAACC,KAAJ,EAAjB,CAAjB;AACA,MAAIC,cAAc,GAAG,CAArB;;AACA,OAAK,IAAIb,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGS,QAAQ,CAACL,MAAjC,EAAyCJ,GAAG,EAA5C,EAAgD;AAC/C,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGQ,QAAQ,CAAC,CAAD,CAAR,CAAYL,MAApC,EAA4CH,GAAG,EAA/C,EAAmD;AAClD,UAAIa,cAAc,GAAGhB,aAAa,CAACC,IAAD,EAAOC,GAAP,EAAYC,GAAZ,CAAlC;;AACA,UAAIa,cAAc,KAAK,CAAvB,EAA0B;AAAE;AAC3BL,QAAAA,QAAQ,CAACT,GAAD,CAAR,CAAcC,GAAd,IAAqB,IAArB;AACAY,QAAAA,cAAc,IAAI,CAAlB;AACA,OAHD,MAGO,IAAIC,cAAc,KAAK,CAAnB,IAAwBL,QAAQ,CAACT,GAAD,CAAR,CAAcC,GAAd,MAAuB,IAAnD,EAAyD;AAAE;AACjEQ,QAAAA,QAAQ,CAACT,GAAD,CAAR,CAAcC,GAAd,IAAqB,IAArB;AACAY,QAAAA,cAAc,IAAI,CAAlB;AACA,OAHM,MAGA;AAAE;AACRJ,QAAAA,QAAQ,CAACT,GAAD,CAAR,CAAcC,GAAd,IAAqB,KAArB;AACA;AACD;AACD;;AAED,SAAO;AACNQ,IAAAA,QADM;AAENI,IAAAA;AAFM,GAAP;AAIA,CAtBM","sourcesContent":["\n/*\n@params: grid: boolean[][], int row, int col\n@result: number of alive adjacent cells\n*/\nexport const getCellsAlive = (grid: boolean[][], row: number, col: number): number => {\n\tlet result = 0;\n\tfor (let i = (row > 0 ? -1 : 0); i < (row < grid.length - 1 ? 2 : 1); i++) {\n\t\tfor (let j = (col > 0 ? -1 : 0); j < (col < grid[0].length - 1 ? 2 : 1); j++) {\n\t\t\tif (i === 0 && j === 0) {\n\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst x = row + i;\n\t\t\tconst y = col + j;\n\t\t\tif (grid[x][y] === true) {\n\t\t\tresult += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport interface NextStateType {\n\tnextGrid: boolean[][],\n\tnextCellsAlive: number,\n}\n\nexport const getNextState = (grid: boolean[][]): NextStateType => {\n\tconst nextGrid = grid.map( arr => arr.slice()); \n\tlet nextCellsAlive = 0;\n\tfor (let row = 0; row < nextGrid.length; row++) {\n\t\tfor (let col = 0; col < nextGrid[0].length; col++) {\n\t\t\tlet aliveNeighbors = getCellsAlive(grid, row, col);\n\t\t\tif (aliveNeighbors === 3) { // any cell with 3 live cells lives\n\t\t\t\tnextGrid[row][col] = true;\n\t\t\t\tnextCellsAlive += 1;\n\t\t\t} else if (aliveNeighbors === 2 && nextGrid[row][col] === true) { // live cells with 2 live cells live\n\t\t\t\tnextGrid[row][col] = true;\n\t\t\t\tnextCellsAlive += 1;\n\t\t\t} else { // all else die or stay dead\n\t\t\t\tnextGrid[row][col] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { \n\t\tnextGrid, \n\t\tnextCellsAlive \n\t};\n}"]},"metadata":{},"sourceType":"module"}