{"ast":null,"code":"/*\n@params: grid: boolean[][], int row, int col\n@result: number of alive adjacent cells\n*/export var getCellsAlive=function getCellsAlive(grid,row,col){var result=0;for(var i=row>0?-1:0;i<(row<grid.length-1?2:1);i++){for(var j=col>0?-1:0;j<(col<grid[0].length-1?2:1);j++){if(i===0&&j===0){continue;}var x=row+i;var y=col+j;if(grid[x][y]===true){result+=1;}}}return result;};export var getNextState=function getNextState(grid){var nextGrid=grid.map(function(arr){return arr.slice();});var nextCellsAlive=0;for(var row=0;row<nextGrid.length;row++){for(var col=0;col<nextGrid[0].length;col++){var aliveNeighbors=getCellsAlive(grid,row,col);if(aliveNeighbors===3){// any cell with 3 live cells lives\nnextGrid[row][col]=true;nextCellsAlive+=1;}else if(aliveNeighbors===2&&nextGrid[row][col]===true){// live cells with 2 live cells live\nnextGrid[row][col]=true;nextCellsAlive+=1;}else{// all else die or stay dead\nnextGrid[row][col]=false;}}}return nextGrid;};","map":{"version":3,"sources":["/home/jschneck/programming_projects/JavaScriptProjects/typed-Game-of-life/john/src/utils.ts"],"names":["getCellsAlive","grid","row","col","result","i","length","j","x","y","getNextState","nextGrid","map","arr","slice","nextCellsAlive","aliveNeighbors"],"mappings":"AACA;AACA;AACA;AACA,EACA,MAAO,IAAMA,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,CAACC,IAAD,CAAoBC,GAApB,CAAiCC,GAAjC,CAAyD,CACrF,GAAIC,CAAAA,MAAM,CAAG,CAAb,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAIH,GAAG,CAAG,CAAN,CAAU,CAAC,CAAX,CAAe,CAA7B,CAAiCG,CAAC,EAAIH,GAAG,CAAGD,IAAI,CAACK,MAAL,CAAc,CAApB,CAAwB,CAAxB,CAA4B,CAAhC,CAAlC,CAAsED,CAAC,EAAvE,CAA2E,CAC1E,IAAK,GAAIE,CAAAA,CAAC,CAAIJ,GAAG,CAAG,CAAN,CAAU,CAAC,CAAX,CAAe,CAA7B,CAAiCI,CAAC,EAAIJ,GAAG,CAAGF,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,CAAiB,CAAvB,CAA2B,CAA3B,CAA+B,CAAnC,CAAlC,CAAyEC,CAAC,EAA1E,CAA8E,CAC7E,GAAIF,CAAC,GAAK,CAAN,EAAWE,CAAC,GAAK,CAArB,CAAwB,CACxB,SACC,CACD,GAAMC,CAAAA,CAAC,CAAGN,GAAG,CAAGG,CAAhB,CACA,GAAMI,CAAAA,CAAC,CAAGN,GAAG,CAAGI,CAAhB,CACA,GAAIN,IAAI,CAACO,CAAD,CAAJ,CAAQC,CAAR,IAAe,IAAnB,CAAyB,CACzBL,MAAM,EAAI,CAAV,CACC,CACD,CACD,CACD,MAAOA,CAAAA,MAAP,CACA,CAfM,CAiBP,MAAO,IAAMM,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAACT,IAAD,CAAoC,CAC/D,GAAMU,CAAAA,QAAQ,CAAGV,IAAI,CAACW,GAAL,CAAU,SAAAC,GAAG,QAAIA,CAAAA,GAAG,CAACC,KAAJ,EAAJ,EAAb,CAAjB,CACA,GAAIC,CAAAA,cAAc,CAAG,CAArB,CACA,IAAK,GAAIb,CAAAA,GAAG,CAAG,CAAf,CAAkBA,GAAG,CAAGS,QAAQ,CAACL,MAAjC,CAAyCJ,GAAG,EAA5C,CAAgD,CAC/C,IAAK,GAAIC,CAAAA,GAAG,CAAG,CAAf,CAAkBA,GAAG,CAAGQ,QAAQ,CAAC,CAAD,CAAR,CAAYL,MAApC,CAA4CH,GAAG,EAA/C,CAAmD,CAClD,GAAIa,CAAAA,cAAc,CAAGhB,aAAa,CAACC,IAAD,CAAOC,GAAP,CAAYC,GAAZ,CAAlC,CACA,GAAIa,cAAc,GAAK,CAAvB,CAA0B,CAAE;AAC3BL,QAAQ,CAACT,GAAD,CAAR,CAAcC,GAAd,EAAqB,IAArB,CACAY,cAAc,EAAI,CAAlB,CACA,CAHD,IAGO,IAAIC,cAAc,GAAK,CAAnB,EAAwBL,QAAQ,CAACT,GAAD,CAAR,CAAcC,GAAd,IAAuB,IAAnD,CAAyD,CAAE;AACjEQ,QAAQ,CAACT,GAAD,CAAR,CAAcC,GAAd,EAAqB,IAArB,CACAY,cAAc,EAAI,CAAlB,CACA,CAHM,IAGA,CAAE;AACRJ,QAAQ,CAACT,GAAD,CAAR,CAAcC,GAAd,EAAqB,KAArB,CACA,CACD,CACD,CAED,MAAOQ,CAAAA,QAAP,CACA,CAnBM","sourcesContent":["\n/*\n@params: grid: boolean[][], int row, int col\n@result: number of alive adjacent cells\n*/\nexport const getCellsAlive = (grid: boolean[][], row: number, col: number): number => {\n\tlet result = 0;\n\tfor (let i = (row > 0 ? -1 : 0); i < (row < grid.length - 1 ? 2 : 1); i++) {\n\t\tfor (let j = (col > 0 ? -1 : 0); j < (col < grid[0].length - 1 ? 2 : 1); j++) {\n\t\t\tif (i === 0 && j === 0) {\n\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst x = row + i;\n\t\t\tconst y = col + j;\n\t\t\tif (grid[x][y] === true) {\n\t\t\tresult += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport const getNextState = (grid: boolean[][]): boolean[][] => {\n\tconst nextGrid = grid.map( arr => arr.slice()); \n\tlet nextCellsAlive = 0;\n\tfor (let row = 0; row < nextGrid.length; row++) {\n\t\tfor (let col = 0; col < nextGrid[0].length; col++) {\n\t\t\tlet aliveNeighbors = getCellsAlive(grid, row, col);\n\t\t\tif (aliveNeighbors === 3) { // any cell with 3 live cells lives\n\t\t\t\tnextGrid[row][col] = true;\n\t\t\t\tnextCellsAlive += 1;\n\t\t\t} else if (aliveNeighbors === 2 && nextGrid[row][col] === true) { // live cells with 2 live cells live\n\t\t\t\tnextGrid[row][col] = true;\n\t\t\t\tnextCellsAlive += 1;\n\t\t\t} else { // all else die or stay dead\n\t\t\t\tnextGrid[row][col] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nextGrid;\n}"]},"metadata":{},"sourceType":"module"}